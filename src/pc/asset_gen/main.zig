//! Converts asset directory into asset struct

const std = @import("std");
const print = std.debug.print;
const eql = std.mem.eql;
const alloc = std.heap.page_allocator;

//tod:
pub fn main() void {
    run() catch |err| {
        switch (err) {
            // Arguments were not given
            error.MissingArgs => {
                print("Make sure to provide an input directory and output path!\n" ++
                    "asset_gen.exe {{input_dir}} {{output_file}}\n", .{});
            },
            // Any other error
            else => {
                print("Error: {}\n", .{err});
            },
        }
        std.process.exit(1);
    };
}

const String = std.ArrayList(u8);
const Writer = String.Writer;

fn run() !void {
    var args = try std.process.argsWithAllocator(alloc);
    defer args.deinit();
    _ = args.skip();

    const input_dir = args.next() orelse return error.MissingArgs;
    const output_path = args.next() orelse return error.MissingArgs;

    var file = String.init(alloc);
    defer file.deinit();
    const writer = file.writer();

    try writer.writeAll(
        \\//! Generated by asset_gen
        \\pub const types = @import("asset_types");
        \\
    );

    var dir = try std.fs.cwd().openDir(input_dir, .{
        .iterate = true,
        .access_sub_paths = false,
    });
    defer dir.close();

    const out_dir = "";
    try doStuff(dir, out_dir, writer);

    var output_file = try std.fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    try output_file.writeAll(file.items);
}

fn doStuff(dir: std.fs.Dir, out_dir: []const u8, writer: Writer) !void {
    var iter = dir.iterate();
    while (try iter.next()) |entry| {

        // Get name in lowercase snake case
        const extension_idx =
            std.mem.indexOf(u8, entry.name, ".") orelse entry.name.len;
        const name = try std.mem.replaceOwned(
            u8,
            alloc,
            entry.name[0..extension_idx],
            " ",
            "_",
        );
        _ = std.ascii.lowerString(name, name);
        defer alloc.free(name);

        switch (entry.kind) {
            .directory => {
                // Create new sub struct for directory
                try writer.print("pub const {s} = struct {{\n", .{name});

                var sub_dir = try dir.openDir(entry.name, .{
                    .iterate = true,
                    .access_sub_paths = false,
                });
                defer sub_dir.close();

                const new_out_dir = try std.fmt.allocPrint(
                    alloc,
                    "{s}{s}/",
                    .{ out_dir, entry.name },
                );
                defer alloc.free(new_out_dir);

                try doStuff(sub_dir, new_out_dir, writer);

                try writer.writeAll("};\n");
            },
            .file => {
                const extension = entry.name[extension_idx..];
                const load_fn =
                    if (eql(u8, extension, ".png"))
                        "loadImage"
                    else if (eql(u8, extension, ".wav"))
                        "loadSound"
                    else
                        continue;

                try writer.print(
                    "pub const {s} = types.{s}(\"{s}{s}\");\n",
                    .{ name, load_fn, out_dir, entry.name },
                );
            },
            else => continue,
        }
    }
}
